# Практические задания

1. Создайте мастер ноду и три воркер ноды (добавьте 6 реплик сервиса containous/whoami, используя yml формат).
2. Повысте worker ноду до статуса масте, а первую ноду масте через которую инициализовали кластер до worker;
3. Выключите одну ноду принудительно(удалив ее). Посмотрите как прераспределились контейнеры.
4. Добавьте еще одну воркер ноду воркер и посмотрте на как перераспределились контейнеры.
5. Создайте yml файл произвольного сервиса и добавьте в него политику обновления.


**1)**

 Сначала создадим мастер-ноду :

```sh
docker swarm init --advertise-addr 192.168.29.0
```

Затем добавим две воркер-ноды (node2 и node3):

```sh
docker swarm join --token SWMTKN-1-0l4oc5yakp7vu87lbp7332fhuzotnxlg1qgg5rgvaonj6s33os-6dx29058plw9mn29116frp0jn 192.168.29.0:2377
```

**2)**

Для повышения воркер-ноды до мастера:

```sh
docker node promote node2
```

Для понижения мастера до воркера:

```sh
docker node demote node1
```

**3)**

Предположим, мы выключаем ноду node2:

```sh
docker node rm node2
```

После выполнения этой команды контейнеры, которые ранее были на ноде node2, распределились между другими доступными нодами.

**4)**

Добавим новую воркер-ноду:

```sh
docker swarm join --token SWMTKN-1-0l4oc5yakp7vu87lbp7332fhuzotnxlg1qgg5rgvaonj6s33os-6dx29058plw9mn29116frp0jn 192.168.29.0:2377
```

   Теперь, после добавления node4, часть контейнеров была перераспределена между имеющимися нодами, включая node4.

**5)**

Создадим файл `docker-compose.yml` со следующим содержимым:

```yaml
   version: '3.8'

   services:
     web:
       image: nginx:latest
       deploy:
         replicas: 3
         update_config:
           parallelism: 2
           delay: 10s
         restart_policy:
           condition: on-failure
```

   Этот файл определяет сервис с тремя репликами, политикой обновления и стратегией перезапуска. Политика обновления говорит Docker Swarm, что обновление сервиса должно выполняться с параллелизмом в 2 контейнера, с задержкой в 10 секунд между обновлениями.

